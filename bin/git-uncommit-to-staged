#!/usr/bin/env bash
set -euo pipefail

# Move all branch commits into the staging area by resetting to the fork point.
# Manual equivalent (typical):
#   git fetch origin
#   git merge-base --fork-point origin/develop HEAD
#   git reset --soft <fork-point>
usage() {
  cat <<'EOF'
Usage: git-uncommit-to-staged [options]

Move commits on the current branch into the staging area by resetting
to the fork point with a base branch.

Options:
  --base <name>        Base branch name (default: develop)
  --remote <name>      Remote name for base (default: origin)
  --local-base         Use <base> as-is without remote prefix
  --no-fetch           Skip git fetch
  -y, --yes, --confirm Assume yes for prompts
  -h, --help, -help    Show help

Notes:
  - This rewrites local history and leaves all changes staged.
EOF
}

confirm() {
  local prompt="$1"
  local reply=""
  read -r -p "$prompt" reply
  case "$reply" in
    [yY]|[yY][eE][sS])
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

base="develop"
remote="origin"
use_remote_prefix=1
do_fetch=1
assume_yes=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help|-help)
      usage
      exit 0
      ;;
    --base)
      shift
      if [[ $# -lt 1 ]]; then
        echo "Missing value for --base" >&2
        usage >&2
        exit 1
      fi
      base="$1"
      ;;
    --remote)
      shift
      if [[ $# -lt 1 ]]; then
        echo "Missing value for --remote" >&2
        usage >&2
        exit 1
      fi
      remote="$1"
      ;;
    --local-base)
      use_remote_prefix=0
      ;;
    --no-fetch)
      do_fetch=0
      ;;
    -y|--yes|--confirm)
      assume_yes=1
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "Unknown option: $1" >&2
      usage >&2
      exit 1
      ;;
  esac
  shift
done

if [[ $# -gt 0 ]]; then
  echo "Unexpected arguments: $*" >&2
  usage >&2
  exit 1
fi

# Require a clean working tree before rewriting history.
if [[ -n "$(git status --porcelain)" ]]; then
  echo "Working tree not clean. Commit or stash changes first." >&2
  exit 1
fi

# Resolve the base ref, defaulting to origin/<base> when applicable.
if [[ "$use_remote_prefix" -eq 1 && "$base" != */* ]]; then
  base_ref="$remote/$base"
else
  base_ref="$base"
fi

# Fetch the remote by default to ensure the base ref is current.
if [[ "$do_fetch" -eq 1 ]]; then
  git fetch "$remote"
fi

# Verify the base ref exists before proceeding.
if ! git rev-parse --verify "$base_ref" >/dev/null 2>&1; then
  echo "Base ref not found: $base_ref" >&2
  exit 1
fi

# Find the fork point; fall back to merge-base if needed.
fork_point="$(git merge-base --fork-point "$base_ref" HEAD 2>/dev/null || true)"
if [[ -z "$fork_point" ]]; then
  fork_point="$(git merge-base "$base_ref" HEAD)"
fi

current_branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)"

# Confirm local history rewrite before the soft reset.
if [[ "$assume_yes" -ne 1 ]]; then
  echo "About to rewrite local history on branch: $current_branch" >&2
  echo "This will move HEAD to fork point: $fork_point" >&2
  echo "All changes since then will be staged as uncommitted changes." >&2
  if ! confirm "Continue? [y/N] "; then
    exit 1
  fi
fi

# Move HEAD to the fork point while keeping all changes staged.
git reset --soft "$fork_point"
